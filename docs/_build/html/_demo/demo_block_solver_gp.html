

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Demo: Using the Block Solver with Nested Splits &mdash; flatiron_tk 0.9.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=39bb1c6d"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Demo: Using the Functions Module" href="demo_functions.html" />
    <link rel="prev" title="Demo: Using the Block Solver for the Navier-Stokes Equations" href="demo_block_solver_nse.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            flatiron_tk
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../toc_modules.html">FLATiron Modules</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../toc_demos.html">FLATiron Demos</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="demo_adios4dolfinx.html">Demo: Using ADIOS4DOLFINx</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_block_solver_nse.html">Demo: Using the Block Solver for the Navier-Stokes Equations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Demo: Using the Block Solver with Nested Splits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#problem-setup">Problem Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#full-script">Full Script</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="demo_functions.html">Demo: Using the Functions Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_scalar_transport_edge_stab.html">Demo: Advection-Diffusion-Reaction with Jump (Edge) Stabilization</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_steady_adr.html">Demo: Steady Advection-Diffusion-Reaction Equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_steady_multiphysics.html">Demo: Steady Multiphysics Simulation (Coupled Diffusion Reaction)</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_steady_navier_stokes.html">Demo: Steady Navier-Stokes</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_steady_stokes.html">Demo: Steady Stokes with External Body Force</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_transient_adr.html">Demo: Transient Advection-Diffusion-Reaction Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="demo_transient_navier_stokes.html">Demo: Transient Navier-Stokes</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">flatiron_tk</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../toc_demos.html">FLATiron Demos</a></li>
      <li class="breadcrumb-item active">Demo: Using the Block Solver with Nested Splits</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/_demo/demo_block_solver_gp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="demo-using-the-block-solver-with-nested-splits">
<h1>Demo: Using the Block Solver with Nested Splits<a class="headerlink" href="#demo-using-the-block-solver-with-nested-splits" title="Link to this heading"></a></h1>
<p>In <a class="reference internal" href="demo_block_solver_nse.html"><span class="doc">Demo: Using the Block Solver for the Navier-Stokes Equations</span></a>, we demonstrated how to use the block solver
to solve the steady Navier-Stokes equations. In that example, we only needed a single split
to define the block structure of the system. In this demo, we will show how to use nested splits
to define a more complex block structure.</p>
<section id="problem-setup">
<h2>Problem Setup<a class="headerlink" href="#problem-setup" title="Link to this heading"></a></h2>
<p>First, we define a simple scalar Galerkin Probject Physics Object to test the block solver with nested splits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">GalerkinProjection</span><span class="p">(</span><span class="n">PhysicsProblem</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GalerkinProjection field_value = b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_projection_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_external_function</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">projection_value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;&#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;&#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_weak_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_function</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_solution_function</span><span class="p">()</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_test_function</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
</pre></div>
</div>
<p>Then we define a helper function to create three GalerkinProjection that we will couple together.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">build_GP</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">GP</span> <span class="o">=</span> <span class="n">GalerkinProjection</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">GP</span><span class="o">.</span><span class="n">set_element</span><span class="p">(</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">GP</span><span class="o">.</span><span class="n">set_projection_value</span><span class="p">(</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">msh</span><span class="p">,</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">default_scalar_type</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">GP</span>
</pre></div>
</div>
<p>Next, we create a mesh and three GalerkinProjection objects using the helper function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">LineMesh</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Define three GP physics with different projection values</span>
<span class="n">GP1</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">GP2</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">GP3</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">GPs</span> <span class="o">=</span> <span class="p">[</span><span class="n">GP1</span><span class="p">,</span> <span class="n">GP2</span><span class="p">,</span> <span class="n">GP3</span><span class="p">]</span>
</pre></div>
</div>
<p>We then monolithically couple the three GalerkinProjection objects using the MultiphysicsProblem class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a multiphysics problem</span>
<span class="n">phs</span> <span class="o">=</span> <span class="n">MultiphysicsProblem</span><span class="p">(</span><span class="o">*</span><span class="n">GPs</span><span class="p">)</span>
<span class="n">phs</span><span class="o">.</span><span class="n">set_element</span><span class="p">()</span>
<span class="n">phs</span><span class="o">.</span><span class="n">build_function_space</span><span class="p">()</span>
<span class="n">phs</span><span class="o">.</span><span class="n">set_weak_form</span><span class="p">()</span>

<span class="c1"># Define the problem</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">NonLinearProblem</span><span class="p">(</span><span class="n">phs</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we define the block structure of the system using nested splits. The first split GP2 from GP1 and GP3, and then we split GP1 and GP3 individually.
Here, we use the default ksp objects for each split. For an example of how to customize the ksp objects, see <a class="reference internal" href="demo_block_solver_nse.html"><span class="doc">Demo: Using the Block Solver for the Navier-Stokes Equations</span></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Split the problem into two blocks: (A,C) and (B)</span>
<span class="n">split0</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fields&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>
            <span class="s1">&#39;composite_type&#39;</span><span class="p">:</span> <span class="s1">&#39;schur&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_fact_type&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_pre_type&#39;</span><span class="p">:</span> <span class="s1">&#39;a11&#39;</span><span class="p">}</span>

<span class="c1"># Second split: (A,C) into (A) and (C)</span>
<span class="n">split1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fields&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">),</span>
            <span class="s1">&#39;composite_type&#39;</span><span class="p">:</span> <span class="s1">&#39;schur&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_fact_type&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_pre_type&#39;</span><span class="p">:</span> <span class="s1">&#39;a11&#39;</span><span class="p">}</span>

<span class="c1"># Create a list of splits to define a tree structure</span>
<span class="n">splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">split0</span><span class="p">,</span> <span class="n">split1</span><span class="p">]</span>

<span class="c1"># Define the tree and solver</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">BlockSplitTree</span><span class="p">(</span><span class="n">phs</span><span class="p">,</span> <span class="n">splits</span><span class="o">=</span><span class="n">splits</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">BlockNonLinearSolver</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">problem</span><span class="p">)</span>

<span class="c1"># Solve the problem</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, we verify that the solution is correct.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Split the solution into its components</span>
<span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_solution_function</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="c1"># Get the dofs for each component</span>
<span class="n">dofs_A</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">dofs_B</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">dofs_C</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Check that the solution is correct</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh vertices:&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">msh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A values at vertices:&quot;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_A</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B values at vertices:&quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_B</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;C values at vertices:&quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_C</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="full-script">
<h2>Full Script<a class="headerlink" href="#full-script" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.info</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="n">adios4dolfinx</span> <span class="o">=</span> <span class="n">import_adios4dolfinx</span><span class="p">()</span>
<span class="n">basix</span> <span class="o">=</span> <span class="n">import_basix</span><span class="p">()</span>
<span class="n">dolfinx</span> <span class="o">=</span> <span class="n">import_dolfinx</span><span class="p">()</span>
<span class="n">PETSc</span> <span class="o">=</span> <span class="n">import_PETSc</span><span class="p">()</span>
<span class="n">ufl</span> <span class="o">=</span> <span class="n">import_ufl</span><span class="p">()</span>
<span class="n">MPI</span> <span class="o">=</span> <span class="n">import_mpi4py</span><span class="p">()</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">LineMesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.physics</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiphysicsProblem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.physics</span><span class="w"> </span><span class="kn">import</span> <span class="n">PhysicsProblem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.solver</span><span class="w"> </span><span class="kn">import</span> <span class="n">NonLinearProblem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.solver</span><span class="w"> </span><span class="kn">import</span> <span class="n">BlockSplitTree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flatiron_tk.solver</span><span class="w"> </span><span class="kn">import</span> <span class="n">BlockNonLinearSolver</span>

<span class="c1"># Build GP physics</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GalerkinProjection</span><span class="p">(</span><span class="n">PhysicsProblem</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GalerkinProjection field_value = b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_projection_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_external_function</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">projection_value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;&#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;&#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_weak_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_function</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_solution_function</span><span class="p">()</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_test_function</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weak_form</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

<span class="c1"># Helper function to build GP physics</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build_GP</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">GP</span> <span class="o">=</span> <span class="n">GalerkinProjection</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">GP</span><span class="o">.</span><span class="n">set_element</span><span class="p">(</span><span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">GP</span><span class="o">.</span><span class="n">set_projection_value</span><span class="p">(</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">msh</span><span class="p">,</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">default_scalar_type</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">GP</span>

<span class="c1"># Create a mesh</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">LineMesh</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Define three GP physics with different projection values</span>
<span class="n">GP1</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">GP2</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">GP3</span> <span class="o">=</span> <span class="n">build_GP</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">GPs</span> <span class="o">=</span> <span class="p">[</span><span class="n">GP1</span><span class="p">,</span> <span class="n">GP2</span><span class="p">,</span> <span class="n">GP3</span><span class="p">]</span>

<span class="c1"># Define a multiphysics problem</span>
<span class="n">phs</span> <span class="o">=</span> <span class="n">MultiphysicsProblem</span><span class="p">(</span><span class="o">*</span><span class="n">GPs</span><span class="p">)</span>
<span class="n">phs</span><span class="o">.</span><span class="n">set_element</span><span class="p">()</span>
<span class="n">phs</span><span class="o">.</span><span class="n">build_function_space</span><span class="p">()</span>
<span class="n">phs</span><span class="o">.</span><span class="n">set_weak_form</span><span class="p">()</span>

<span class="c1"># Define the problem</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">NonLinearProblem</span><span class="p">(</span><span class="n">phs</span><span class="p">)</span>

<span class="c1"># Split the problem into two blocks: (A,C) and (B)</span>
<span class="n">split0</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fields&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>
            <span class="s1">&#39;composite_type&#39;</span><span class="p">:</span> <span class="s1">&#39;schur&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_fact_type&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_pre_type&#39;</span><span class="p">:</span> <span class="s1">&#39;a11&#39;</span><span class="p">}</span>

<span class="c1"># Second split: (A,C) into (A) and (C)</span>
<span class="n">split1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fields&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">),</span>
            <span class="s1">&#39;composite_type&#39;</span><span class="p">:</span> <span class="s1">&#39;schur&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_fact_type&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;schur_pre_type&#39;</span><span class="p">:</span> <span class="s1">&#39;a11&#39;</span><span class="p">}</span>

<span class="c1"># Create a list of splits to define a tree structure</span>
<span class="n">splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">split0</span><span class="p">,</span> <span class="n">split1</span><span class="p">]</span>

<span class="c1"># Define the tree and solver</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">BlockSplitTree</span><span class="p">(</span><span class="n">phs</span><span class="p">,</span> <span class="n">splits</span><span class="o">=</span><span class="n">splits</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">BlockNonLinearSolver</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">problem</span><span class="p">)</span>

<span class="c1"># Solve the problem</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c1"># Split the solution into its components</span>
<span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_solution_function</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="c1"># Get the dofs for each component</span>
<span class="n">dofs_A</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">dofs_B</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">dofs_C</span> <span class="o">=</span> <span class="n">phs</span><span class="o">.</span><span class="n">get_function_space</span><span class="p">()</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">dofmap</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Check that the solution is correct</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh vertices:&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">msh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A values at vertices:&quot;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_A</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B values at vertices:&quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_B</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;C values at vertices:&quot;</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">dofs_C</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="demo_block_solver_nse.html" class="btn btn-neutral float-left" title="Demo: Using the Block Solver for the Navier-Stokes Equations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demo_functions.html" class="btn btn-neutral float-right" title="Demo: Using the Functions Module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Nick Rovito.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>